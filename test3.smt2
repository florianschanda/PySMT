(set-logic AUFBVNIRA)
(set-info :source |VC generated by SPARK 2014|)
(set-info :smt-lib-version 2.0)
(set-info :category industrial)
(set-info :status unknown)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-fun real () ty)

(declare-fun bool () ty)

(declare-fun match_bool (ty Bool uni uni) uni)

;; match_bool_sort
  (assert
  (forall ((a ty))
  (forall ((x Bool) (x1 uni) (x2 uni)) (sort a (match_bool a x x1 x2)))))

;; match_bool_True
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni)) (=> (sort a z) (= (match_bool a true z z1) z)))))

;; match_bool_False
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni))
  (=> (sort a z1) (= (match_bool a false z z1) z1)))))

(declare-fun index_bool (Bool) Int)

;; index_bool_True
  (assert (= (index_bool true) 0))

;; index_bool_False
  (assert (= (index_bool false) 1))

(declare-fun tuple0 () ty)

(declare-fun Tuple0 () uni)

;; Tuple0_sort
  (assert (sort tuple0 Tuple0))

(declare-fun qtmark () ty)

(declare-sort ref1 1)

(declare-fun ref (ty) ty)

(declare-fun mk_ref (ty uni) uni)

;; mk ref_sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort (ref a) (mk_ref a x)))))

(declare-fun mk_ref1 (Int) (ref1 Int))

(declare-fun contents (ty uni) uni)

;; contents_sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort a (contents a x)))))

(declare-fun t2tb ((ref1 Int)) uni)

;; t2tb_sort
  (assert (forall ((x (ref1 Int))) (sort (ref int) (t2tb x))))

(declare-fun tb2t (uni) (ref1 Int))

;; BridgeL
  (assert
  (forall ((i (ref1 Int))) (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; BridgeR
  (assert
  (forall ((j uni)) (! (= (t2tb (tb2t j)) j) :pattern ((t2tb (tb2t j))) )))

(declare-fun t2tb1 (Int) uni)

;; t2tb_sort
  (assert (forall ((x Int)) (sort int (t2tb1 x))))

(declare-fun tb2t1 (uni) Int)

;; BridgeL
  (assert
  (forall ((i Int)) (! (= (tb2t1 (t2tb1 i)) i) :pattern ((t2tb1 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (= (t2tb1 (tb2t1 j)) j) :pattern ((t2tb1 (tb2t1 j))) )))

;; contents_def
  (assert (forall ((u Int)) (= (tb2t1 (contents int (t2tb (mk_ref1 u)))) u)))

;; contents_def
  (assert
  (forall ((a ty))
  (forall ((u uni)) (=> (sort a u) (= (contents a (mk_ref a u)) u)))))

(declare-fun us__ignore (ty uni) uni)

;; ___ignore_sort
  (assert
  (forall ((a ty)) (forall ((x uni)) (sort tuple0 (us__ignore a x)))))

(declare-fun us_private () ty)

(declare-fun us_null_ext__ () uni)

;; __null_ext___sort
  (assert (sort us_private us_null_ext__))

(declare-fun us_type_of_heap () ty)

(declare-fun us_image () ty)

(declare-fun ite1 (ty Bool uni uni) uni)

;; ite_sort
  (assert
  (forall ((a ty))
  (forall ((x Bool) (x1 uni) (x2 uni)) (sort a (ite1 a x x1 x2)))))

(define-fun to_int1 ((b Bool)) Int (ite (= b true) 1 0))

(define-fun of_int ((i Int)) Bool (ite (= i 0) false true))

(define-fun in_range ((x Int)) Bool (or (= x 0) (= x 1)))

(declare-fun attr__ATTRIBUTE_IMAGE (Bool) uni)

;; attr__ATTRIBUTE_IMAGE_sort
  (assert (forall ((x Bool)) (sort us_image (attr__ATTRIBUTE_IMAGE x))))

(declare-fun attr__ATTRIBUTE_VALUE__pre_check (uni) Bool)

(declare-fun attr__ATTRIBUTE_VALUE (uni) Bool)

(declare-sort integer 0)

(declare-fun integer1 () ty)

(define-fun in_range1 ((x Int)) Bool (and (<= (- 2147483648) x)
                                     (<= x 2147483647)))

(define-fun bool_eq ((x Int) (y Int)) Bool (ite (= x y) true false))

(declare-fun attr__ATTRIBUTE_IMAGE1 (Int) uni)

;; attr__ATTRIBUTE_IMAGE_sort
  (assert (forall ((x Int)) (sort us_image (attr__ATTRIBUTE_IMAGE1 x))))

(declare-fun attr__ATTRIBUTE_VALUE__pre_check1 (uni) Bool)

(declare-fun attr__ATTRIBUTE_VALUE1 (uni) Int)

(declare-fun to_rep (integer) Int)

(declare-fun of_rep (Int) integer)

(declare-fun user_eq (integer integer) Bool)

(declare-fun dummy () integer)

;; inversion_axiom
  (assert
  (forall ((x integer)) (! (= (of_rep (to_rep x)) x) :pattern ((to_rep x)) )))

;; range_axiom
  (assert
  (forall ((x integer)) (! (in_range1 (to_rep x)) :pattern ((to_rep x)) )))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range1 x) (= (to_rep (of_rep x)) x)) :pattern ((to_rep
                                                            (of_rep x))) )))

(declare-fun dividend () Int)

(declare-fun divisor () Int)

(declare-fun attr__ATTRIBUTE_ADDRESS () Int)

(declare-fun attr__ATTRIBUTE_ADDRESS1 () Int)

(declare-fun quotient13 () Int)

(declare-fun remainder12 () Int)

(declare-fun o3 () Int)

(declare-fun o4 () Int)

(declare-fun quotient14 () Int)

(declare-fun remainder13 () Int)

(declare-fun quotient15 () Int)

(declare-fun remainder14 () Int)

(declare-fun quotient16 () Int)

(declare-fun remainder15 () Int)

(declare-fun quotient17 () Int)

(declare-fun remainder16 () Int)

(declare-fun quotient18 () Int)

(declare-fun remainder17 () Int)

(declare-fun quotient19 () Int)

(declare-fun remainder18 () Int)

(declare-fun quotient20 () Int)

(declare-fun remainder19 () Int)

(declare-fun quotient21 () Int)

(declare-fun remainder20 () Int)

(declare-fun quotient22 () Int)

(declare-fun remainder21 () Int)

(define-fun remainder22 () (ref1 Int) (mk_ref1 remainder18))

(define-fun quotient23 () (ref1 Int) (mk_ref1 quotient19))

;; H
  (assert (in_range1 dividend))

;; H
  (assert (in_range1 divisor))

;; H
  (assert (=> (<= (- 2147483648) 2147483647) (in_range1 quotient13)))

;; H
  (assert (=> (<= (- 2147483648) 2147483647) (in_range1 remainder12)))

;; H
  (assert (and (< 0 divisor) (<= 0 dividend)))

;; H
  (assert (= quotient14 0))

;; H
  (assert (= remainder13 dividend))

;; H
  (assert
  (=> (<= divisor remainder13)
  (or
  (and
  (and
  (and
  (and (and (<= 0 remainder14) (<= 0 quotient15))
  (= (+ (* divisor quotient15) remainder14) dividend)) false)
  (and (and (= remainder14 remainder16) (= quotient15 quotient17))
  (and (= remainder17 remainder14) (= quotient18 quotient15))))
  (and
  (and (= remainder22 (mk_ref1 remainder16))
  (= quotient23 (mk_ref1 quotient17)))
  (and (= remainder19 remainder17) (= quotient20 quotient18))))
  (and
  (and
  (and (and (<= 0 remainder14) (<= 0 quotient15))
  (= (+ (* divisor quotient15) remainder14) dividend))
  (and
  (and (=> (<= (- 2147483648) 2147483647) (in_range1 quotient15))
  (and (=> (<= (- 2147483648) 2147483647) (in_range1 remainder14))
  (<= divisor remainder14)))
  (and
  (and (and (= o3 (+ quotient15 1)) (in_range1 (+ quotient15 1)))
  (= quotient16 o3))
  (and
  (and
  (and (= o4 (- remainder14 divisor)) (in_range1 (- remainder14 divisor)))
  (= remainder15 o4)) (not (<= divisor remainder15))))))
  (and (and (= remainder15 remainder18) (= quotient16 quotient19))
  (and (= remainder19 remainder15) (= quotient20 quotient16)))))))

;; H
  (assert (=> (not (<= divisor remainder13)) (= remainder13 remainder18)))

;; H
  (assert (=> (not (<= divisor remainder13)) (= quotient14 quotient19)))

;; H
  (assert (=> (not (<= divisor remainder13)) (= remainder19 remainder13)))

;; H
  (assert (=> (not (<= divisor remainder13)) (= quotient20 quotient14)))

;; H
  (assert (= (mk_ref1 remainder20) remainder22))

;; H
  (assert (= (mk_ref1 quotient21) quotient23))

;; H
  (assert (= remainder21 remainder19))

;; H
  (assert (= quotient22 quotient20))

(assert
;; WP_parameter_def
 ;; File "/home/florian/ac/spark2014/benchmark_script/data/tmp-test-euclidian_division-3079/src/gnatprove/linear_div/../linear_div.mlw", line 1056, characters 5-8
  (not
  (and
  (and (and (<= 0 quotient21) (<= 0 remainder20)) (< remainder20 divisor))
  (= (+ (* divisor quotient21) remainder20) dividend))))
(check-sat)
